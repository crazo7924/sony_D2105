/*
 * Copyright (C) 2011 Google Inc.  All rights reserved.
 * Copyright (C) 2014 Sony Mobile Communications AB
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef WorkerThreadableWebSocketChannel_h
#define WorkerThreadableWebSocketChannel_h

#if ENABLE(WEB_SOCKETS) && ENABLE(WORKERS)

#include "PlatformString.h"
#include "ThreadableWebSocketChannel.h"
#include "WebSocketChannelClient.h"
//SOMC KK PATCH Patches_w15.5_begin
#include "WorkerContext.h"
//SOMC KK PATCH Patches_w15.5_end

#include <wtf/PassRefPtr.h>
#include <wtf/RefCounted.h>
#include <wtf/RefPtr.h>
#include <wtf/Threading.h>

namespace WebCore {

class KURL;
class ScriptExecutionContext;
class ThreadableWebSocketChannelClientWrapper;
class WorkerContext;
class WorkerLoaderProxy;
class WorkerRunLoop;

class WorkerThreadableWebSocketChannel : public RefCounted<WorkerThreadableWebSocketChannel>, public ThreadableWebSocketChannel {
    WTF_MAKE_FAST_ALLOCATED;
public:
//SOMC KK PATCH Patches_w15.5_begin
//    static PassRefPtr<ThreadableWebSocketChannel> create(WorkerContext* workerContext, WebSocketChannelClient* client, const String& taskMode, const KURL& url, const String& protocol)
//    {
//        return adoptRef(new WorkerThreadableWebSocketChannel(workerContext, client, taskMode, url, protocol));
//    }
    static PassRefPtr<ThreadableWebSocketChannel> create(WorkerContext* workerContext, WebSocketChannelClient* client, const String& taskMode)
    {
        return adoptRef(new WorkerThreadableWebSocketChannel(workerContext, client, taskMode));
    }
//SOMC KK PATCH Patches_w15.5_end
    virtual ~WorkerThreadableWebSocketChannel();

//SOMC KK PATCH Patches_w15.5_begin
//    virtual void connect();
//    virtual bool send(const String& message);
    // ThreadableWebSocketChannel functions.
    virtual bool useHixie76Protocol();
    virtual void connect(const KURL&, const String& protocol);
    virtual String subprotocol();
    virtual String extensions();
    virtual ThreadableWebSocketChannel::SendResult send(const String& message);
    virtual ThreadableWebSocketChannel::SendResult send(const ArrayBuffer&);
    virtual ThreadableWebSocketChannel::SendResult send(const Blob&);
//SOMC KK PATCH Patches_w15.5_end
    virtual unsigned long bufferedAmount() const;
//SOMC KK PATCH Patches_w15.5_begin
//    virtual void close();
    virtual void close(int code, const String& reason);
    virtual void fail(const String& reason);
//SOMC KK PATCH Patches_w15.5_end
    virtual void disconnect(); // Will suppress didClose().
    virtual void suspend();
    virtual void resume();

//SOMC KK PATCH Patches_w15.5_begin
//    using RefCounted<WorkerThreadableWebSocketChannel>::ref;
//    using RefCounted<WorkerThreadableWebSocketChannel>::deref;

//protected:
//    virtual void refThreadableWebSocketChannel() { ref(); }
//    virtual void derefThreadableWebSocketChannel() { deref(); }

//private:
//SOMC KK PATCH Patches_w15.5_end
    // Generated by the bridge.  The Peer and its bridge should have identical
    // lifetimes.
    class Peer : public WebSocketChannelClient {
        WTF_MAKE_NONCOPYABLE(Peer); WTF_MAKE_FAST_ALLOCATED;
    public:
//SOMC KK PATCH Patches_w15.5_begin
//        static Peer* create(RefPtr<ThreadableWebSocketChannelClientWrapper> clientWrapper, WorkerLoaderProxy& loaderProxy, ScriptExecutionContext* context, const String& taskMode, const KURL& url, const String& protocol)
//        {
//            return new Peer(clientWrapper, loaderProxy, context, taskMode, url, protocol);
//        }
        static Peer* create(PassRefPtr<ThreadableWebSocketChannelClientWrapper> clientWrapper, WorkerLoaderProxy& loaderProxy, ScriptExecutionContext* context, const String& taskMode)
        {
            return new Peer(clientWrapper, loaderProxy, context, taskMode);
        }
//SOMC KK PATCH Patches_w15.5_end
        ~Peer();

//SOMC KK PATCH Patches_w15.5_begin
//        void connect();
        bool useHixie76Protocol();
        void connect(const KURL&, const String& protocol);
//SOMC KK PATCH Patches_w15.5_end
        void send(const String& message);
//SOMC KK PATCH Patches_w15.5_begin
        void send(const ArrayBuffer&);
        void send(const Blob&);
//SOMC KK PATCH Patches_w15.5_end
        void bufferedAmount();
//SOMC KK PATCH Patches_w15.5_begin
//        void close();
        void close(int code, const String& reason);
        void fail(const String& reason);
//SOMC KK PATCH Patches_w15.5_end
        void disconnect();
        void suspend();
        void resume();

        // WebSocketChannelClient functions.
        virtual void didConnect();
        virtual void didReceiveMessage(const String& message);
//SOMC KK PATCH Patches_w15.5_begin
//        virtual void didClose(unsigned long unhandledBufferedAmount);
        virtual void didReceiveBinaryData(PassOwnPtr<Vector<char> >);
        virtual void didUpdateBufferedAmount(unsigned long bufferedAmount);
        virtual void didStartClosingHandshake();
        virtual void didClose(unsigned long unhandledBufferedAmount, ClosingHandshakeCompletionStatus, unsigned short code, const String& reason);
//SOMC KK PATCH Patches_w15.5_end

    private:
//SOMC KK PATCH Patches_w15.5_begin
//        Peer(RefPtr<ThreadableWebSocketChannelClientWrapper>, WorkerLoaderProxy&, ScriptExecutionContext*, const String& taskMode, const KURL&, const String& protocol);
        Peer(PassRefPtr<ThreadableWebSocketChannelClientWrapper>, WorkerLoaderProxy&, ScriptExecutionContext*, const String& taskMode);
//SOMC KK PATCH Patches_w15.5_end

        RefPtr<ThreadableWebSocketChannelClientWrapper> m_workerClientWrapper;
        WorkerLoaderProxy& m_loaderProxy;
        RefPtr<ThreadableWebSocketChannel> m_mainWebSocketChannel;
        String m_taskMode;
    };

//SOMC KK PATCH Patches_w15.5_begin
    using RefCounted<WorkerThreadableWebSocketChannel>::ref;
    using RefCounted<WorkerThreadableWebSocketChannel>::deref;

protected:
    virtual void refThreadableWebSocketChannel() { ref(); }
    virtual void derefThreadableWebSocketChannel() { deref(); }

private:
//SOMC KK PATCH Patches_w15.5_end
    // Bridge for Peer.  Running on the worker thread.
    class Bridge : public RefCounted<Bridge> {
    public:
//SOMC KK PATCH Patches_w15.5_begin
//        static PassRefPtr<Bridge> create(PassRefPtr<ThreadableWebSocketChannelClientWrapper> workerClientWrapper, PassRefPtr<WorkerContext> workerContext, const String& taskMode, const KURL& url, const String& protocol)
//        {
//            return adoptRef(new Bridge(workerClientWrapper, workerContext, taskMode, url, protocol));
//        }
        static PassRefPtr<Bridge> create(PassRefPtr<ThreadableWebSocketChannelClientWrapper> workerClientWrapper, PassRefPtr<WorkerContext> workerContext, const String& taskMode)
        {
            return adoptRef(new Bridge(workerClientWrapper, workerContext, taskMode));
        }
//SOMC KK PATCH Patches_w15.5_end
        ~Bridge();
//SOMC KK PATCH Patches_w15.5_begin
//        void connect();
//        bool send(const String& message);
        void initialize();
        void connect(const KURL&, const String& protocol);
        ThreadableWebSocketChannel::SendResult send(const String& message);
        ThreadableWebSocketChannel::SendResult send(const ArrayBuffer&);
        ThreadableWebSocketChannel::SendResult send(const Blob&);
//SOMC KK PATCH Patches_w15.5_end
        unsigned long bufferedAmount();
//SOMC KK PATCH Patches_w15.5_begin
//        void close();
        void close(int code, const String& reason);
        void fail(const String& reason);
//SOMC KK PATCH Patches_w15.5_end
        void disconnect();
        void suspend();
        void resume();

        using RefCounted<Bridge>::ref;
        using RefCounted<Bridge>::deref;

    private:
//SOMC KK PATCH Patches_w15.5_begin
//        Bridge(PassRefPtr<ThreadableWebSocketChannelClientWrapper>, PassRefPtr<WorkerContext>, const String& taskMode, const KURL&, const String& protocol);

//        static void setWebSocketChannel(ScriptExecutionContext*, Bridge* thisPtr, Peer*, RefPtr<ThreadableWebSocketChannelClientWrapper>);

//        // Executed on the main thread to create a Peer for this bridge.
//        static void mainThreadCreateWebSocketChannel(ScriptExecutionContext*, Bridge* thisPtr, RefPtr<ThreadableWebSocketChannelClientWrapper>, const String& taskMode, const KURL&, const String& protocol);
        Bridge(PassRefPtr<ThreadableWebSocketChannelClientWrapper>, PassRefPtr<WorkerContext>, const String& taskMode);

        static void setWebSocketChannel(ScriptExecutionContext*, Bridge* thisPtr, Peer*, PassRefPtr<ThreadableWebSocketChannelClientWrapper>, bool useHixie76Protocol);

        // Executed on the main thread to create a Peer for this bridge.
        static void mainThreadInitialize(ScriptExecutionContext*, WorkerLoaderProxy*, PassRefPtr<ThreadableWebSocketChannelClientWrapper>, const String& taskMode);
//SOMC KK PATCH Patches_w15.5_end

        // Executed on the worker context's thread.
        void clearClientWrapper();

        void setMethodNotCompleted();
        void waitForMethodCompletion();

        RefPtr<ThreadableWebSocketChannelClientWrapper> m_workerClientWrapper;
        RefPtr<WorkerContext> m_workerContext;
        WorkerLoaderProxy& m_loaderProxy;
        String m_taskMode;
        Peer* m_peer;
    };

//SOMC KK PATCH Patches_w15.5_begin
//    WorkerThreadableWebSocketChannel(WorkerContext*, WebSocketChannelClient*, const String& taskMode, const KURL&, const String& protocol);

//    static void mainThreadConnect(ScriptExecutionContext*, Peer*);
    WorkerThreadableWebSocketChannel(WorkerContext*, WebSocketChannelClient*, const String& taskMode);

    static void mainThreadConnect(ScriptExecutionContext*, Peer*, const KURL&, const String& protocol);
//SOMC KK PATCH Patches_w15.5_end
    static void mainThreadSend(ScriptExecutionContext*, Peer*, const String& message);
//SOMC KK PATCH Patches_w15.5_begin
    static void mainThreadSendArrayBuffer(ScriptExecutionContext*, Peer*, PassOwnPtr<Vector<char> >);
    static void mainThreadSendBlob(ScriptExecutionContext*, Peer*, const KURL&, const String& type, long long size);
//SOMC KK PATCH Patches_w15.5_end
    static void mainThreadBufferedAmount(ScriptExecutionContext*, Peer*);
//SOMC KK PATCH Patches_w15.5_begin
//    static void mainThreadClose(ScriptExecutionContext*, Peer*);
//    static void mainThreadDestroy(ScriptExecutionContext*, Peer*);
    static void mainThreadClose(ScriptExecutionContext*, Peer*, int code, const String& reason);
    static void mainThreadFail(ScriptExecutionContext*, Peer*, const String& reason);
    static void mainThreadDestroy(ScriptExecutionContext*, PassOwnPtr<Peer>);
//SOMC KK PATCH Patches_w15.5_end
    static void mainThreadSuspend(ScriptExecutionContext*, Peer*);
    static void mainThreadResume(ScriptExecutionContext*, Peer*);

    RefPtr<WorkerContext> m_workerContext;
    RefPtr<ThreadableWebSocketChannelClientWrapper> m_workerClientWrapper;
    RefPtr<Bridge> m_bridge;
};

} // namespace WebCore

#endif // ENABLE(WEB_SOCKETS)

#endif // WorkerThreadableWebSocketChannel_h
